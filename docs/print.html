<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kenny Kerr</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <meta property="og:image" content="https://kennykerr.ca/image.jpg"/>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="rust-getting-started/index.html">Getting Started with Rust</a></li><li class="chapter-item expanded "><a href="rust-getting-started/windows-or-windows-sys.html"><strong aria-hidden="true">1.</strong> Choosing between the windows and windows-sys crates</a></li><li class="chapter-item expanded "><a href="rust-getting-started/how-are-crates-built.html"><strong aria-hidden="true">2.</strong> How are these crates built?</a></li><li class="chapter-item expanded "><a href="rust-getting-started/how-to-find-api.html"><strong aria-hidden="true">3.</strong> How do I find a particular API?</a></li><li class="chapter-item expanded "><a href="rust-getting-started/what-apis-are-included.html"><strong aria-hidden="true">4.</strong> What APIs are included?</a></li><li class="chapter-item expanded "><a href="rust-getting-started/where-are-the-macros.html"><strong aria-hidden="true">5.</strong> Where's my favorite macro from the Windows SDK?</a></li><li class="chapter-item expanded "><a href="rust-getting-started/calling-your-first-windows-api.html"><strong aria-hidden="true">6.</strong> Calling your first API with the windows crate</a></li><li class="chapter-item expanded "><a href="rust-getting-started/calling-your-first-windows-sys-api.html"><strong aria-hidden="true">7.</strong> Calling your first API with the windows-sys crate</a></li><li class="chapter-item expanded "><a href="rust-getting-started/calling-your-first-com-api.html"><strong aria-hidden="true">8.</strong> Calling your first COM API</a></li><li class="chapter-item expanded "><a href="rust-getting-started/calling-your-first-winrt-api.html"><strong aria-hidden="true">9.</strong> Calling your first WinRT API</a></li><li class="chapter-item expanded "><a href="rust-getting-started/how-to-query-for-com-interface.html"><strong aria-hidden="true">10.</strong> How do I query for a specific COM interface?</a></li><li class="chapter-item expanded "><a href="rust-getting-started/how-to-implement-com-interface.html"><strong aria-hidden="true">11.</strong> How do I implement an existing COM interface?</a></li><li class="chapter-item expanded "><a href="rust-getting-started/how-to-implement-winrt-collection.html"><strong aria-hidden="true">12.</strong> How do I create stock collections for WinRT collection interfaces?</a></li><li class="chapter-item expanded "><a href="rust-getting-started/understanding-windows-targets.html"><strong aria-hidden="true">13.</strong> Understanding the windows-targets crate</a></li><li class="chapter-item expanded "><a href="rust-getting-started/standalone-code-generation.html"><strong aria-hidden="true">14.</strong> Standalone code generation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kenny Kerr</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/kennykerr/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Kenny Kerr is a Software Engineer at Microsoft where he works on C++ and Rust tools and libraries for the Windows operating system. He is the creator of <a href="https://github.com/microsoft/cppwinrt">C++/WinRT</a> and <a href="https://github.com/microsoft/windows-rs">Rust for Windows</a>. Kenny also wrote recurring columns and feature articles for C/C++ Users Journal, Visual Studio Magazine, MSDN Magazine, originally called Microsoft Systems Journal.</p>
<p><a href="rust-getting-started">Getting Started with Rust</a></p>
<p><a href="https://www.pluralsight.com/authors/kenny-kerr">Kenny's courses on Pluralsight</a></p>
<p><a href="https://github.com/kennykerr">Kenny on GitHub</a></p>
<p><a href="https://www.youtube.com/@kennykerrca/videos">Kenny on YouTube</a></p>
<p><a href="https://www.linkedin.com/in/kennykerr/">Kenny on LinkedIn</a></p>
<p><a href="https://kennykerrca.wordpress.com/">Kenny's old blog on WordPress</a></p>
<p><a href="https://weblogs.asp.net/kennykerr">Kenny's old blog on asp.net</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-rust"><a class="header" href="#getting-started-with-rust">Getting Started with Rust</a></h1>
<p>The <a href="https://github.com/microsoft/windows-rs">windows-rs</a> project has been available for some time and while I still have a great deal of work left to do, I thought I should start spending some time writing about Rust for Windows and not simply building Rust for Windows. ðŸ˜Š As I did for <a href="https://github.com/microsoft/cppwinrt">C++/WinRT</a>, I thought I would start writing a few short &quot;how to&quot; or &quot;how it works&quot; articles to help developers understand some of the fundamentals of the <a href="https://github.com/microsoft/windows-rs">windows-rs</a> project.</p>
<p>Some of these topics will be obvious for Rust developers but perhaps not the Windows developer new to Rust. Other topics might be obvious to Windows developers but less so to the seasoned Rust developer new to Windows. Either way, I hope you find it useful. Feel free to <a href="https://github.com/microsoft/windows-rs/issues">open an issue on the repo</a> if you have any questions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-between-the-windows-and-windows-sys-crates"><a class="header" href="#choosing-between-the-windows-and-windows-sys-crates">Choosing between the windows and windows-sys crates</a></h1>
<p>The <a href="https://crates.io/crates/windows">windows</a> crate provides bindings for the Windows API, including C-style APIs like <code>CreateThreadpool</code> as well as COM and WinRT APIs like DirectX. This crate provides the most comprehensive API coverage for the Windows operating system. Where possible, the <code>windows</code> crate also attempts to provide a more idiomatic and safe programming model for Rust developers.</p>
<p>The <a href="https://crates.io/crates/windows-sys">windows-sys</a> crate provides raw bindings for the C-style Windows APIs. It lacks support for COM and WinRT APIs. The <code>windows-sys</code> crate was born out of the realization that the most expensive aspect of the <code>windows</code> crate, in terms of build time, is the cost of compiling function bodies. The Rust compiler just spends a great deal of effort compiling function bodies, so a version of the <code>windows</code> crate that only includes declarations is both much smaller and faster by comparison. The trouble is that COM-style virtual function calls require extra code gen in Rust (unlike C++) and this in turn leads to slower compile times. Enter the <code>windows-sys</code> crate.</p>
<p>Of course, we continue to work hard at improving performance both in terms of the underlying Rust compiler toolchain as well as the efficiency of the code generated for these crates. We are thus confident that the compile-time will continue to improve.</p>
<div class="table-wrapper"><table><thead><tr><th>What do you need?</th><th><code>windows</code></th><th><code>windows-sys</code></th></tr></thead><tbody>
<tr><td>Fast compile times are one of your top concerns</td><td></td><td>âœ…</td></tr>
<tr><td>You need <code>no_std</code> support</td><td></td><td>âœ…</td></tr>
<tr><td>You need COM or WinRT support</td><td>âœ…</td><td></td></tr>
<tr><td>You would prefer to use APIs that feel idiomatic to Rust</td><td>âœ…</td><td></td></tr>
<tr><td>Minimum supported Rust version</td><td>1.56</td><td>1.56</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="how-are-these-crates-built"><a class="header" href="#how-are-these-crates-built">How are these crates built?</a></h1>
<p>The <a href="https://crates.io/crates/windows">windows</a> and <a href="https://crates.io/crates/windows-sys">windows-sys</a> crates are generated from metadata describing the Windows API. Originally only WinRT APIs included metadata, but metadata is now provided for older C and COM APIs as well. The <a href="https://github.com/microsoft/win32metadata/">win32metadata</a> project provides the tools to produce the metadata and the <a href="https://crates.io/crates/windows-metadata">windows-metadata</a> and <a href="https://crates.io/crates/windows-bindgen">windows-bindgen</a> crates are used to read the metadata and generate the <code>windows</code> and <code>windows-sys</code> crates. The bindings are generated differently based on the differing goals of the respective crates. You can find the exact metadata files used to generate a particular version of the <code>windows</code> and <code>windows-sys</code> crates <a href="https://github.com/microsoft/windows-rs/tree/master/crates/libs/bindgen/default">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-find-a-particular-api"><a class="header" href="#how-do-i-find-a-particular-api">How do I find a particular API?</a></h1>
<p>First <a href="rust-getting-started/windows-or-windows-sys.html">pick the crate you would like to use</a>. Then search the documentation for the chosen crate:</p>
<ul>
<li>
<p><a href="https://microsoft.github.io/windows-docs-rs/">windows</a></p>
</li>
<li>
<p><a href="https://docs.rs/windows-sys">windows-sys</a></p>
</li>
</ul>
<p>Note that the docs include a note indicating which features to enable in order to access a particular API. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-apis-are-included"><a class="header" href="#what-apis-are-included">What APIs are included?</a></h1>
<p>All Windows APIs provided by the Windows SDK are included, with a few exceptions. The definitions of these APIs are collected from <a href="rust-getting-started/how-are-crates-built.html">metadata and transformed into Rust bindings</a>. The process of generating the Rust bindings purposefully omits a few APIs. APIs are only excluded if they are (1) unsuitable for Rust developers and (2) impose a large hit on the overall size of the <a href="https://crates.io/crates/windows">windows</a> and <a href="https://crates.io/crates/windows-sys">windows-sys</a> crates. </p>
<p>The Xaml API is excluded because it is all but unusable without direct language support that only the Xaml team can provide. Xaml is also focused and tailored for C# app development so this API isn't applicable to Rust developers. The MsHtml API is also excluded because it is only intended for Microsoft's older scripting languages like JScript and VBScript. It is also by far the single largest module as measured in lines of code. Beyond that, a few deprecrated and unusable APIs are excluded. You can see exactly what the <a href="https://github.com/microsoft/windows-rs/blob/59950e2e2b7bd79f2de2020ee33745d7f642230f/crates/tools/windows/src/main.rs#L4-L5">windows crate excludes</a> and what the <a href="https://github.com/microsoft/windows-rs/blob/59950e2e2b7bd79f2de2020ee33745d7f642230f/crates/tools/sys/src/main.rs#L5-L35">windows-sys crate excludes</a>.</p>
<p>Beyond that, the <code>windows-sys</code> crate currently excludes all COM and WinRT APIs. The <code>windows-sys</code> crate only includes declarations and COM and WinRT calls are far too cumbersome without the abstractions provided by the windows crate. Here are some tips for <a href="rust-getting-started/windows-or-windows-sys.html">choosing between the windows and windows-sys crates</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wheres-my-favorite-macro-from-the-windows-sdk"><a class="header" href="#wheres-my-favorite-macro-from-the-windows-sdk">Where's my favorite macro from the Windows SDK?</a></h1>
<p>The <a href="https://crates.io/crates/windows">windows</a> and <a href="https://crates.io/crates/windows-sys">windows-sys</a> crates are <a href="rust-getting-started/how-are-crates-built.html">generated from metadata</a>. This metadata only includes type definitions and function signatures, not macros, header-only functions, or function bodies. You may find some equivalents of common C/C++ helper macros and functions in the <code>windows</code> crate, but in general the macros don't have direct equivalents in the <code>windows</code> or <code>windows-sys</code> crates. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-your-first-api-with-the-windows-crate"><a class="header" href="#calling-your-first-api-with-the-windows-crate">Calling your first API with the windows crate</a></h1>
<p>So you want to get a feel for calling a simple Windows API. Where to start? Let's look at a relatively simple API for submitting callbacks to the thread pool. You can read <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/august/windows-with-c-the-windows-thread-pool-and-work">more about this API here</a>.</p>
<p>The first step is to add a dependency on the <a href="https://crates.io/crates/windows">windows</a> crate and indicate which features you'd like to access:</p>
<pre><code class="language-toml">[dependencies.windows]
version = &quot;0.52&quot;
features = [
    &quot;Win32_Foundation&quot;,
    &quot;Win32_System_Threading&quot;,
]
</code></pre>
<p>Why these two features? Well, the thread pool API is defined in the <code>Win32::System::Threading</code> module and we'll also use a handful of definitions from the <code>Win32::Foundation</code> module. If you're unsure, the docs for any given API provide a helpful comment indicating which features are required. For example, here are the docs for <a href="https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/Threading/fn.WaitForThreadpoolWorkCallbacks.html">WaitForThreadpoolWorkCallbacks</a> where you can see it depends on both of these features since it is defined in the <code>Win32::System::Threading</code> module and depends on <code>BOOL</code> which is defined in the <code>Win32::Foundation</code> module.</p>
<p>Cargo will now handle the heavy lifting, tracking down the dependencies and making sure the import libs are present, so that we can simply call these APIs in Rust without any further configuration. We can employ a <code>use</code> declaration to make these APIs a little more accessible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use windows::{core::Result, Win32::System::Threading::*};
<span class="boring">}</span></code></pre></pre>
<p>In order to &quot;prove&quot; that the code works and yet keep it real simple let's just use the thread pool to increment a counter some number of times. Here we can use a reader-writer lock for safe and multi-threaded access to the counter variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static COUNTER: std::sync::RwLock&lt;i32&gt; = std::sync::RwLock::new(0);
<span class="boring">}</span></code></pre></pre>
<p>For this example, I'll just use a simple <code>main</code> function with a big <code>unsafe</code> block since virtually everything here is going to be <code>unsafe</code>. Why is that? Well the <code>windows</code> crate lets you call foreign functions and these are generally assumed to be <code>unsafe</code>. </p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
    unsafe {
        
    }

    Ok(())
}</code></pre></pre>
<p>The thread pool API is modeled as a set of &quot;objects&quot; exposed via a traditional C-style API. The first thing we need to do is create a work object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let work = CreateThreadpoolWork(Some(callback), None, None)?;
<span class="boring">}</span></code></pre></pre>
<p>The first parameter is a pointer to a callback function. The remaining parameters are optional and you can read more about them in my thread pool series on MSDN.</p>
<p>The callback itself must be a valid C-style callback according to the signature expected by the thread pool API. Here's a simple callback that will increment the count:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;system&quot; fn callback(_: PTP_CALLBACK_INSTANCE, _: *mut std::ffi::c_void, _: PTP_WORK) {
    let mut counter = COUNTER.write().unwrap();
    *counter += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>The parameters can safely be ignored but do come in handy from time to time. At this point, we have a valid work object but nothing is happening yet. In order to kick off some &quot;work&quot;, we need to submit the work object to the thread pool. You can do so as many times as you'd like, so lets go ahead and do it ten times:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for _ in 0..10 {
    SubmitThreadpoolWork(work);
}
<span class="boring">}</span></code></pre></pre>
<p>You can now expect the callbacks to run concurrently, hence the <code>RwLock</code> above. Of course, with all of that concurrency we need some way to tell when the work is done. That's the job of the <code>WaitForThreadpoolWorkCallbacks</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WaitForThreadpoolWorkCallbacks(work, false);
<span class="boring">}</span></code></pre></pre>
<p>The second parameter indicates whether we would like to cancel any pending callbacks that have not started to execute. Passing false here thus indicates that we would like the wait function to block until all of the submitted work has completed. At that point, we can safely close the work object to free its memory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CloseThreadpoolWork(work);
<span class="boring">}</span></code></pre></pre>
<p>And just to prove that it works reliably, we can print out the counter's value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let counter = COUNTER.read().unwrap();
println!(&quot;counter: {}&quot;, *counter);
<span class="boring">}</span></code></pre></pre>
<p>Running the sample should print something like this:</p>
<pre><code>counter: 10
</code></pre>
<p>Here's the <a href="https://github.com/microsoft/windows-rs/blob/master/crates/samples/windows/thread_pool_work/src/main.rs">full sample for reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-your-first-api-with-the-windows-sys-crate"><a class="header" href="#calling-your-first-api-with-the-windows-sys-crate">Calling your first API with the windows-sys crate</a></h1>
<p>So you want to get a feel for calling a simple Windows API. Where to start? Let's look at a relatively simple API for submitting callbacks to the thread pool. You can read <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/august/windows-with-c-the-windows-thread-pool-and-work">more about this API here</a>.</p>
<p>The first step is to add a dependency on the <a href="https://crates.io/crates/windows-sys">windows-sys</a> crate and indicate which features you'd like to access:</p>
<pre><code class="language-toml">[dependencies.windows-sys]
version = &quot;0.52&quot;
features = [
    &quot;Win32_Foundation&quot;,
    &quot;Win32_System_Threading&quot;,
]
</code></pre>
<p>Why these two features? Well, the thread pool API is defined in the <code>Win32::System::Threading</code> module and we'll also use a handful of definitions from the <code>Win32::Foundation</code> module. If you're unsure, the docs for any given API provide a helpful comment indicating which features are required. For example, here are the docs for <a href="https://docs.rs/windows-sys/latest/windows_sys/Win32/System/Threading/fn.WaitForThreadpoolWorkCallbacks.html">WaitForThreadpoolWorkCallbacks</a> where you can see it depends on both of these features since it is defined in the <code>Win32::System::Threading</code> module and depends on <code>BOOL</code> which is defined in the <code>Win32::Foundation</code> module.</p>
<p>Cargo will now handle the heavy lifting, tracking down the dependencies and making sure the import libs are present, so that we can simply call these APIs in Rust without any further configuration. We can employ a <code>use</code> declaration to make these APIs a little more accessible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use windows_sys::{Win32::Foundation::*, Win32::System::Threading::*};
<span class="boring">}</span></code></pre></pre>
<p>In order to &quot;prove&quot; that the code works and yet keep it real simple let's just use the thread pool to increment a counter some number of times. Here we can use a reader-writer lock for safe and multi-threaded access to the counter variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static COUNTER: std::sync::RwLock&lt;i32&gt; = std::sync::RwLock::new(0);
<span class="boring">}</span></code></pre></pre>
<p>For this example, I'll just use a simple <code>main</code> function with a big <code>unsafe</code> block since virtually everything here is going to be <code>unsafe</code>. Why is that? Well the <code>windows</code> crate lets you call foreign functions and these are generally assumed to be <code>unsafe</code>. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    unsafe {
        
    }
}</code></pre></pre>
<p>The thread pool API is modeled as a set of &quot;objects&quot; exposed via a traditional C-style API. The first thing we need to do is create a work object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let work = CreateThreadpoolWork(Some(callback), std::ptr::null_mut(), std::ptr::null());
<span class="boring">}</span></code></pre></pre>
<p>The first parameter is a pointer to a callback function. The remaining parameters are optional and you can read more about them in my thread pool series on MSDN.</p>
<p>Since this function allocates memory, it is possible that it might fail, and this is indicated by returning a null pointer rather than a valid work object handle. We'll check for this condition and call the <code>GetLastError</code> function to display any relevant error code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if work == 0 {
    println!(&quot;{:?}&quot;, GetLastError());
    return;
}
<span class="boring">}</span></code></pre></pre>
<p>The callback itself must be a valid C-style callback according to the signature expected by the thread pool API. Here's a simple callback that will increment the count:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;system&quot; fn callback(_: PTP_CALLBACK_INSTANCE, _: *mut std::ffi::c_void, _: PTP_WORK) {
    let mut counter = COUNTER.write().unwrap();
    *counter += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>The parameters can safely be ignored but do come in handy from time to time. At this point, we have a valid work object but nothing is happening yet. In order to kick off some &quot;work&quot;, we need to submit the work object to the thread pool. You can do so as many times as you'd like, so lets go ahead and do it ten times:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for _ in 0..10 {
    SubmitThreadpoolWork(work);
}
<span class="boring">}</span></code></pre></pre>
<p>You can now expect the callbacks to run concurrently, hence the <code>RwLock</code> above. Of course, with all of that concurrency we need some way to tell when the work is done. That's the job of the <code>WaitForThreadpoolWorkCallbacks</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WaitForThreadpoolWorkCallbacks(work, 0);
<span class="boring">}</span></code></pre></pre>
<p>The second parameter indicates whether we would like to cancel any pending callbacks that have not started to execute. Passing <code>0</code>, meaning false, here thus indicates that we would like the wait function to block until all of the submitted work has completed. At that point, we can safely close the work object to free its memory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CloseThreadpoolWork(work);
<span class="boring">}</span></code></pre></pre>
<p>And just to prove that it works reliably, we can print out the counter's value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let counter = COUNTER.read().unwrap();
println!(&quot;counter: {}&quot;, *counter);
<span class="boring">}</span></code></pre></pre>
<p>Running the sample should print something like this:</p>
<pre><code>counter: 10
</code></pre>
<p>Here's the <a href="https://github.com/microsoft/windows-rs/blob/master/crates/samples/windows-sys/thread_pool_work/src/main.rs">full sample for reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-your-first-com-api"><a class="header" href="#calling-your-first-com-api">Calling your first COM API</a></h1>
<p>COM APIs are unique in that they expose functionality through interfaces. An interface is just a collection of virtual function pointers grouped together in what is known as a vtable, or virtual function table. This is not something that Rust supports directly, like C++ does, but the <a href="https://crates.io/crates/windows">windows</a> crate provides the necessary code gen to make it possible and seamless. A COM API will still typically start life through a traditional C-style function call in order to get your hands on a COM interface. From there you might call other methods via the interface. </p>
<p>Some COM-based APIs can get real complicated so let's start with a very simple example. The <code>CreateUri</code> function is <a href="https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775098(v=vs.85)">officially documented on MSDN</a> as returning the <code>IUri</code> interface representing the results of parsing the given URI. The Rust <a href="https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/Com/fn.CreateUri.html">docs for the windows crate</a> indicate that it resides in the <code>Win32::System::Com</code> module so we can configure our <code>windows</code> crate dependency accordingly:</p>
<pre><code class="language-toml">[dependencies.windows]
version = &quot;0.52&quot;
features = [
    &quot;Win32_System_Com&quot;,
]
</code></pre>
<p>And we can employ a <code>use</code> declaration to make this API a little more accessible. The <code>windows</code> crate's <code>core</code> module also provides a few helpers to make it easier to work with COM interfaces, so we'll include that as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use windows::{core::*, Win32::System::Com::*};
<span class="boring">}</span></code></pre></pre>
<p>For this example, I'll just use a simple <code>main</code> function with a big <code>unsafe</code> block since virtually everything here is going to be <code>unsafe</code>. Why is that? Well the <code>windows</code> crate lets you call foreign functions and these are generally assumed to be <code>unsafe</code>. </p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
    unsafe {
        
        Ok(())
    }
}</code></pre></pre>
<p>The only &quot;interesting&quot; point here is the use of the <code>Result</code> type from the <code>windows::core</code> module that provides Windows error handling to simplify the following API calls. And with that, we can call the <code>CreateUri</code> function as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uri = CreateUri(w!(&quot;http://kennykerr.ca&quot;), Uri_CREATE_CANONICALIZE, 0)?;
<span class="boring">}</span></code></pre></pre>
<p>There's quite a lot going on here. The first parameter is actually a <code>PCWSTR</code>, representing a null-terminated wide string used by many Windows APIs. The <code>windows</code> crate provides the handy <code>w!</code> macro for creating a valid null-terminated wide string as a compile-time constant. The second parameter is just the default flag specified by the official documentation. The third parameter is reserved and should thus be zero.</p>
<p>The resulting <code>IUri</code> object has various methods that we can now use to inspect the URI. The <a href="https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775038(v=vs.85)">official documentation</a> describes the various interface methods and <a href="https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/Com/struct.IUri.html">the Rust docs</a> give you a quick glimpse at their various signatures so that you can quickly figure out how to call them in Rust. For this example, let's just call two of them to print out the URI's domain and the HTTP port number:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let domain = uri.GetDomain()?;
let port = uri.GetPort()?;

println!(&quot;{domain} ({port})&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Under the hood, those methods will invoke the virtual functions through the COM interface and into the implementation provided by the API. They also provide a bunch of error and signature transformation to make it very natural to use from Rust. And that's it, running the sample should print something like this:</p>
<pre><code>kennykerr.ca (80)
</code></pre>
<p>Here's the <a href="https://github.com/microsoft/windows-rs/blob/master/crates/samples/windows/com_uri/src/main.rs">full sample for reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-your-first-winrt-api"><a class="header" href="#calling-your-first-winrt-api">Calling your first WinRT API</a></h1>
<p>Windows 8 introduced the Windows Runtime, which at its heart, is just COM with a few more conventions thrown in to make language bindings appear more seamless. The <a href="https://crates.io/crates/windows">windows</a> crate already makes calling COM APIs far more seamless than it is for C++ developers, but WinRT goes further by providing first-class support for modeling things like constructors, events, and class hierarchies. In <a href="rust-getting-started/calling-your-first-com-api.html">calling your first COM API</a>, we saw that you still had to bootstrap the API with a C-style DLL export before calling COM interface methods. WinRT works the same way but abstracts this away in a generalized manner. </p>
<p>Let's use a simple example to illustrate. The <code>XmlDocument</code> &quot;class&quot; models an XML document that can be loaded from various sources. The Rust <a href="https://microsoft.github.io/windows-docs-rs/doc/windows/Data/Xml/Dom/struct.XmlDocument.html">docs for the windows crate</a> indicate that this type resides in the <code>Data::Xml::Dom</code> module so we can configure our <code>windows</code> crate dependency as follows:</p>
<pre><code class="language-toml">[dependencies.windows]
version = &quot;0.52&quot; 
features = [
    &quot;Data_Xml_Dom&quot;,
]
</code></pre>
<p>And we can employ a <code>use</code> declaration to make this API a little more accessible. The <code>windows</code> crate's <code>core</code> module just provides a few helpers to make it easier to work with Windows APIs, so we'll include that as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use windows::{core::*, Data::Xml::Dom::XmlDocument}; 
<span class="boring">}</span></code></pre></pre>
<p>For this example, I'll just use a simple <code>main</code> function with a <code>Result</code> type from the <code>windows::core</code> module to provide automatic error propagation and simplify the subsequent API calls: </p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {

    Ok(())
}</code></pre></pre>
<p>Unlike the previous Win32 and COM examples, you'll notice that this <code>main</code> function does not need an <code>unsafe</code> block since WinRT calls are assumed to be safe thanks to its more constrained type-system.</p>
<p>To begin, we can simply call the <code>new</code> method to create a new <code>XmlDocument</code> object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let doc = XmlDocument::new()?;
<span class="boring">}</span></code></pre></pre>
<p>This looks a lot more like an idiomatic Rust type than your typical COM API, but under the hood a similar mechanism is used to instantiate the <code>XmlDocument</code> implementation via a DLL export. We can then call the <code>LoadXml</code> method to test it out. There are various other options for loading XML from different sources, which you can <a href="https://learn.microsoft.com/en-us/uwp/api/windows.data.xml.dom.xmldocument?view=winrt-22621">read about in the official documentation</a> or from the Rust docs for the <code>XmlDocument</code> API. The <code>windows</code> crate also provides the handy <code>h!</code> macro for creating an <code>HSTRING</code>, the string type used by WinRT APIs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>doc.LoadXml(h!(&quot;&lt;html&gt;hello world&lt;/html&gt;&quot;))?;
<span class="boring">}</span></code></pre></pre>
<p>And just like that, we have a fully-formed Xml document that we can inspect. For this example, let's just grab the document element and then do some basic queries as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let root = doc.DocumentElement()?;
assert!(root.NodeName()? == &quot;html&quot;);
println!(&quot;{}&quot;, root.InnerText()?);
<span class="boring">}</span></code></pre></pre>
<p>First we assert that the element's name is in fact &quot;html&quot; and then print out the element's inner text. As with the previous COM example, those methods all invoke virtual functions through COM interfaces, but the <code>windows</code> crate makes it very simple to make such calls directly from Rust. And that's it. Running the sample should print something like this:</p>
<pre><code>hello world
</code></pre>
<p>Here's the <a href="https://github.com/microsoft/windows-rs/blob/master/crates/samples/windows/xml/src/main.rs">full sample for reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-query-for-a-specific-com-interface"><a class="header" href="#how-do-i-query-for-a-specific-com-interface">How do I query for a specific COM interface?</a></h1>
<p>COM and WinRT interfaces in the <a href="https://crates.io/crates/windows">windows</a> crate implement the <a href="https://microsoft.github.io/windows-docs-rs/doc/windows/core/trait.ComInterface.html">ComInterface</a> trait. This trait provides the <code>cast</code> method that will use <code>QueryInterface</code> under the hood to cast the current interface to another interface supported by the object. The <code>cast</code> method returns a <code>Result&lt;T&gt;</code> so that failure can be handled in a natural way in Rust.</p>
<p>For example, it is often necesary to get the <code>IDXGIDevice</code> interface for a given Direct3D device to interop with other rendering APIs. This is how you might create a swap chain for drawing and presenting to a Direct3D device. Let's imagine a simple function that accepts a Direct3D device and returns the underlying DXGI factory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_dxgi_factory(device: &amp;ID3D11Device) -&gt; Result&lt;IDXGIFactory2&gt; {
}
<span class="boring">}</span></code></pre></pre>
<p>The first thing you need to do is query or cast the Direct3D device for its DXGI interface as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let device = device.cast::&lt;IDXGIDevice&gt;()?;
<span class="boring">}</span></code></pre></pre>
<p>If its more convenient, you can also make use of type inference as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let device: IDXGIDevice = device.cast()?;
<span class="boring">}</span></code></pre></pre>
<p>With the COM interface in hand, we need an <code>unsafe</code> block to call its methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
}
<span class="boring">}</span></code></pre></pre>
<p>Within the <code>unsafe</code> block, we can retrieve the device's physical adapter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let adapter = device.GetAdapter()?;
<span class="boring">}</span></code></pre></pre>
<p>And just for fun (or debugging), we might print out the adapter's name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if cfg!(debug_assertions) {
    let mut desc = Default::default();
    adapter.GetDesc(&amp;mut desc)?;
    println!(&quot;{}&quot;, String::from_utf16_lossy(&amp;desc.Description));
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, we can return the adapter's parent and also the DXGI factory object for the device:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>adapter.GetParent()
<span class="boring">}</span></code></pre></pre>
<p>Running the sample I get the following impressive results:</p>
<pre><code>AMD FirePro W4100
</code></pre>
<p>Here's a <a href="https://github.com/microsoft/windows-rs/tree/master/crates/samples/windows/direct2d">more comprehensive DirectX example</a>.</p>
<p>The <code>cast</code> method works equally well for WinRT classes and interfaces. It is particularly useful for <a href="https://github.com/microsoft/windows-rs/blob/master/crates/samples/windows/uiautomation/src/main.rs">interop with WinRT APIs</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-implement-an-existing-com-interface"><a class="header" href="#how-do-i-implement-an-existing-com-interface">How do I implement an existing COM interface?</a></h1>
<p>In some cases, you may need to implement an existing COM interface rather than simply calling an existing implementation provided by the operating system. This is where the <code>implement</code> feature and macro come in handy. The <a href="https://crates.io/crates/windows">windows</a> crate provides optional implementation support hidden behind the <code>implement</code> feature. Once enabled, the <a href="https://docs.rs/windows-implement/latest/windows_implement/attr.implement.html">implement</a> macro may be used to implement any number of COM interfaces. The macro takes care of implementing <code>IUnknown</code> itself. </p>
<p>Let's implement a simple interface defined by Windows to illustrate. The <code>IPersist</code> interface is defined in the <code>Win32::System::Com</code> module, so we'll start by adding a dependency on the <code>windows</code> crate and include the <code>Win32_System_Com</code> feature:</p>
<pre><code class="language-toml">[dependencies.windows]
version = &quot;0.52&quot;
features = [
    &quot;implement&quot;,
    &quot;Win32_System_Com&quot;,
]
</code></pre>
<p>The <code>implement</code> feature unlocks the implementation support. </p>
<p>The <code>implement</code> macro is included by the <code>windows::core</code> module so we'll keep things simple by including it all as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use windows::{core::*, Win32::System::Com::*};
<span class="boring">}</span></code></pre></pre>
<p>Now its time for the implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[implement(IPersist)]
struct Persist(GUID);
<span class="boring">}</span></code></pre></pre>
<p>The <code>implement</code> macro will provide the necessary implementation for the <code>IUnknown</code> interface's lifetime management and interface discovery for whatever interfaces are included in the attribute. In this case, only <code>IPersist</code> is to be implemented. </p>
<p>The implementation itself is defined by a trait that follows the <code>&lt;interface name&gt;_Impl</code> pattern and its up to us to implement it for our implementation as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IPersist_Impl for Persist {
    fn GetClassID(&amp;self) -&gt; Result&lt;GUID&gt; {
        Ok(self.0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The IPersist interface, originally <a href="https://learn.microsoft.com/en-us/windows/win32/api/objidl/nn-objidl-ipersist">documented here</a>, has a single method that returns a <code>GUID</code>, so we'll just implement it by returning the value contained within our implementation. The <code>window</code> crate and <code>implement</code> macro will take care of the rest by providing the actual COM virtual function call and virtual function table layout needed to turn this into a heap-allocated and reference-counted COM object. </p>
<p>All that remains is to move, or box, the implementation into the COM implementation provided by the <code>implement</code> macro through the <code>Into</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guid = GUID::new()?;
let persist: IPersist = Persist(guid).into();
<span class="boring">}</span></code></pre></pre>
<p>At this point, we can simply treat <code>persist</code> as the COM object that it is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guid2 = unsafe { persist.GetClassID()? };
assert_eq!(guid, guid2);
println!(&quot;{:?}&quot;, guid);
<span class="boring">}</span></code></pre></pre>
<p>Here's a <a href="https://github.com/microsoft/windows-rs/tree/master/crates/samples/windows/bits">complete example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-create-stock-collections-for-winrt-collection-interfaces"><a class="header" href="#how-do-i-create-stock-collections-for-winrt-collection-interfaces">How do I create stock collections for WinRT collection interfaces?</a></h1>
<p>Beyond <a href="rust-getting-started/how-to-implement-com-interface.html">implementing COM interfaces</a> yourself, the <a href="https://crates.io/crates/windows">windows</a> crate provides stock collection implementations for common WinRT collection interfaces. Implementing WinRT collection interfaces can be quite challenging, so this should save you a lot of effort in many cases. The <code>implement</code> feature is required to make use of these stock implementations.</p>
<p>Let's consider a few examples. The WinRT collection interfaces are all defined in the <code>Foundation::Collections</code> module, so we'll start by adding a dependency on the <code>windows</code> crate and include the <code>Foundation_Collections</code> feature:</p>
<pre><code class="language-toml">[dependencies.windows]
version = &quot;0.52&quot;
features = [
    &quot;implement&quot;,
    &quot;Foundation_Collections&quot;,
]
</code></pre>
<p>Creating a collection is as simple as using the <code>TryFrom</code> trait on existing <code>Vec</code> or <code>BTreeMap</code>, depending on the kind of collection:</p>
<div class="table-wrapper"><table><thead><tr><th>WinRT interface</th><th>From</th></tr></thead><tbody>
<tr><td><code>IIterable&lt;T&gt;</code></td><td><code>Vec&lt;T::Default&gt;</code></td></tr>
<tr><td><code>IVectorView&lt;T&gt;</code></td><td><code>Vec&lt;T::Default&gt;</code></td></tr>
<tr><td><code>IMapView&lt;K, V&gt;</code></td><td><code>BTreeMap&lt;K::Default, V::Default&gt;</code></td></tr>
</tbody></table>
</div>
<p>So if you need a <code>IIterable</code> implementation of <code>i32</code> values you can create it as follows:</p>
<pre><pre class="playground"><code class="language-rust">use windows::{core::*, Foundation::Collections::*};

fn main() -&gt; Result&lt;()&gt; {
    let collection = IIterable::&lt;i32&gt;::try_from(vec![1, 2, 3])?;

    for n in collection {
        println!(&quot;{n}&quot;);
    }

    Ok(())
}</code></pre></pre>
<p>The resulting <code>collection</code> will implement all of the specialized <code>IIterable&lt;i32&gt;</code> methods. </p>
<p>Did you notice the <code>T::Default</code> in the table above? The challenge is that when the WinRT collection contains nullable types, unlike <code>i32</code>, then the collection must necessarily support a backing implementation that support expressing this. The <code>Default</code> associated type just replaces <code>T</code> with <code>Option&lt;T&gt;</code> for such nullable, or reference, types. </p>
<p>Let's consider a slightly more contrived example. Here we'll create an <code>IMapView</code> with strings for keys and interfaces for values. WinRT strings are not nullable but interfaces are. WinRT strings are represented by <code>HSTRING</code> in the <code>windows</code> crate and for the interface we'll just use an <code>IStringable</code> implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use windows::Foundation::*;

#[implement(IStringable)]
struct Value(&amp;'static str);

impl IStringable_Impl for Value {
    fn ToString(&amp;self) -&gt; Result&lt;HSTRING&gt; {
        Ok(self.0.into())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can now create a <code>std</code> collection as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;

let map = BTreeMap::from([
    (&quot;hello&quot;.into(), Some(Value(&quot;HELLO&quot;).into())),
    (&quot;hello&quot;.into(), Some(Value(&quot;WORLD&quot;).into())),
]);
<span class="boring">}</span></code></pre></pre>
<p>The Rust compiler naturally infers the exact type: <code>BTreeMap&lt;HSTRING, Option&lt;IStringable&gt;&gt;</code>.</p>
<p>Finally, we can wrap that <code>BTreeMap</code> inside a WinRT collection with the <code>TryInto</code> trait as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map: IMapView&lt;HSTRING, IStringable&gt; = map.try_into()?;

for pair in map {
    println!(&quot;{} - {}&quot;, pair.Key()?, pair.Value()?.ToString()?);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-the-windows-targets-crate"><a class="header" href="#understanding-the-windows-targets-crate">Understanding the windows-targets crate</a></h1>
<p>The <a href="https://crates.io/crates/windows">windows</a> and <a href="https://crates.io/crates/windows-sys">windows-sys</a> crates depend on the <a href="https://crates.io/crates/windows-targets">windows-targets</a> crate for linker support. The <code>windows-targets</code> crate includes import libs, supports semantic versioning, and optional support for <code>raw-dylib</code>. It provides explicit import libraries for the following targets:</p>
<ul>
<li>i686_msvc</li>
<li>x86_64_msvc</li>
<li>aarch64_msvc</li>
<li>i686_gnu</li>
<li>x86_64_gnu</li>
<li>x86_64_gnullvm</li>
<li>aarch64_gnullvm</li>
</ul>
<p>An import lib contains information the linker uses to resolve external references to functions exported by DLLs. This allows the operating system to identify a specific DLL and function export at load time. Import libs are both toolchain- and architecture-specific. In other words, different lib files are required depending on whether you're compiling with the MSVC or GNU toolchains and whether you're compiling for the x86 or ARM64 architectures. Note that import libraries don't contain any code, as static libraries do.</p>
<p>While the GNU and MSVC toolchains often provide some import libs to support C++ development, those lib files are often incomplete, missing, or just plain wrong. This can lead to linker errors that are very difficult to diagnose. The <code>windows-targets</code> crate ensures that all functions defined by the <code>windows</code> and <code>windows-sys</code> crates can be linked without relying on implicit lib files distributed by the toolchain. This ensures that dependencies can be managed with Cargo and streamlines cross-compilation. The <code>windows-targets</code> crate also contains version-specific lib file names ensuring semver compatibility. Without this capability, the linker will simply pick the first matching lib file name and fail to resolve any missing or mismatched imports. </p>
<blockquote>
<p><strong>Note</strong>: Ordinarily, you don't need to think about the <code>windows-targets</code> crate at all. The <code>windows</code> and <code>windows-sys</code> crates depend on the <code>windows-targets</code> crate automatically. Only in rare cases will you need to use it directly. </p>
</blockquote>
<p>Start by adding the following to your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies.windows-targets]
version = &quot;0.52&quot;
</code></pre>
<p>Use the <code>link</code> macro to define the external functions you wish to call:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>windows_targets::link!(&quot;kernel32.dll&quot; &quot;system&quot; fn SetLastError(code: u32));
windows_targets::link!(&quot;kernel32.dll&quot; &quot;system&quot; fn GetLastError() -&gt; u32);
<span class="boring">}</span></code></pre></pre>
<p>Make use of any Windows APIs as needed:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    unsafe {
        SetLastError(1234);
        assert_eq!(GetLastError(), 1234);
    }
}</code></pre></pre>
<p>By default the <code>link</code> macro will cause the linker to use the bundled import libs. Compiling with the <code>windows_raw_dylib</code> Rust build flag will cause Cargo to skip downloading the import libs altogether and instead use <code>raw-dylib</code> to resolve imports automatically. The Rust compiler will then create the import entries directly. This works without having to change any of your code. Without the <code>windows-targets</code> crate, switching between linker and <code>raw-dylib</code> imports requires very intricate code changes. As of this writing, the <code>raw-dylib</code> feature is not yet stable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standalone-code-generation"><a class="header" href="#standalone-code-generation">Standalone code generation</a></h1>
<p>Even with a <a href="rust-getting-started/windows-or-windows-sys.html">choice between the windows and windows-sys crates</a>, some developers may prefer to use completely standalone bindings. The <a href="https://crates.io/crates/windows-bindgen">windows-bindgen</a> crate lets you generate entirely standalone bindings for Windows APIs with a single function call that you can run from a test to automate the generation of bindings. This can help to reduce your dependencies while continuing to provide a sustainable path forward for any future API requirements you might have, or just to refresh your bindings from time to time to pick up any bug fixes automatically from Microsoft.</p>
<blockquote>
<p><strong>Warning</strong>: Standalone code generation should only be used as a last resort for the most demanding scenarios. It is much simpler to use the <a href="https://crates.io/crates/windows-sys">windows-sys</a> crate and let Cargo manage this dependency. This <code>windows-sys</code> crate provides raw bindings, is heavily tested and widely used, and should not meaningfully impact your build time. </p>
</blockquote>
<p>Start by adding the following to your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies.windows-targets]
version = &quot;0.52&quot;

[dev-dependencies.windows-bindgen]
version = &quot;0.52&quot;
</code></pre>
<p>The <code>windows-bindgen</code> crate is only needed for generating bindings and is thus a dev dependency only. The <a href="https://crates.io/crates/windows-targets">windows-targets</a> crate is a dependency shared by the <code>windows</code> and <code>windows-sys</code> crates and only contains import libs for supported targets. This will ensure that you can link against any Windows API functions you may need. </p>
<p>Write a test to generate bindings as follows:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn bindgen() {
    let args = [
        &quot;--out&quot;,
        &quot;src/bindings.rs&quot;,
        &quot;--config&quot;,
        &quot;flatten&quot;,
        &quot;--filter&quot;,
        &quot;Windows.Win32.System.SystemInformation.GetTickCount&quot;,
    ];

    windows_bindgen::bindgen(args).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>Make use of any Windows APIs as needed.</p>
<pre><code class="language-rust no_run ignore">mod bindings;

fn main() {
    unsafe {
        println!(&quot;{}&quot;, bindings::GetTickCount());
    }
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
